Packet loss appears to be an inevitable issue in computing and has spurred the development of systems to mitigate its effects for decades. A prime example of such a system is Digital Fountain Codes developed by Michael Luby at his company Digital Fountain (reference), published in 2002. A Digital Fountain Code (DFC) is a type of sparse-graph code designed for transmission channels that have erasure. In practice, DFCs are a robust and efficient solution for transmitting data in a lossless manner and with a low cost.
When packets are sent through a channel with erasure, they are either received without error or not received. At first glance, an easy solution to communicating successfully over these channels might be to include a feedback channel that allows the receiver to acknowledge that packets have been received, based on this data the broadcaster transmitting data can then resend the required packets. This solution has the benefit that it will work regardless of the erasure probability, however, if that probability is large across a channel, then the protocol will be wasteful. More messages will be sent across the feedback channel and the receiver will likely get multiple of the same packets because erasure will affect both feedback and transmission channels. This example breaks down further when looking at a broadcast channel. Let’s say a broadcaster is transmitting to 1000 individuals over a channel, every time they don’t receive a packet, they must request it from the broadcaster who then resends that packet. Every time the broadcaster does this, the packet will go to all receivers. Most transmissions of resending packets will likely be redundant as most receivers will have already received them.
 A more practical solution is to therefore remove the feedback channel and allow a constant data stream over the transmission channel. To implement this with a DFC system, on a basic level, the broadcaster needs to have an encoder to encode packets that are being transmitted and a degree distribution to encode the packets against. Receivers will need to have a decoder and a knowledge of the degree distribution of packets for the data being transmitted so that they can decode the data by matching encoded packets to source packets. Using this method, a receiver will need to receive little more than 105% of the size of the source packets in encoded packets to successfully decode the data. Furthermore, it doesn’t matter what packets the receiver has as long as they have enough, they can decode the data from the degree distribution which maps encoded packets, otherwise known as check nodes, to multiple source packets allowing for packet retrieval.
Although the main application of DFCs is for broadcasting data, they can also be utilised to reduce the risk of data loss in long-term HDD or magnetic tape storage. A DFC can be used to spread packets throughout a storage system, meaning that if any packets become corrupted, they can be ignored, and the backup data can be successfully recovered from the remaining packets.
My interest in DFCs lies in being able to create a near-perfect efficiency for a degree distribution to implement a fast and resource-cheap solution. As I research this project, I hope to further my knowledge and understanding surrounding erasure channels and degree distributions including Luby’s distributions designed for DFCs. Hence, I aim to analyse and optimise my solution throughout development to reach better time and space efficiency. 
